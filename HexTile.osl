// Hex Tile Shader - hexagonal tile coordinates with randomization for UV offsets to breakup repeating textures
/*
   Copyright 2023 Edward Darby Edelen

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

shader HexTile(
    float tiles=5.
    [[string label="Tiles", float min=1, float max=100000, float slidermin=1, float slidermax=50]],
    float soft = 0.2
    [[string label="Blend Amount", float min=0, float max=1, float slidermin=0, float slidermax=1]],
    float height_weight = 1
    [[string label="Height Weight", string page="Height", float min = 0, float max = 2, float slidermin=0, float slidermax=1]],
    string height_texture = ""
    [[string label="Height Texture", string widget="filename", string page="Height"]],
    float noise_weight = 0
    [[string label="Noise Weight", string widget="number", string page="Noise", float min=0, float max=2, float slidermin=0, float slidermax=1]],
    float noise_uniform_scale = 1
    [[string label="Noise Uniform Scale", string widget="number", string page="Noise", float min=0.0001, float slidermin=0.1, float slidermax=10]],
    vector noise_scale = 1
    [[string label="Noise Scale", string page="Noise", float sensitivity=0.1]],
    vector noise_offset = 0
    [[string label="Noise Offset", string widget="number", string page="Noise"]],
    int seed = 12345
    [[string label="Random Seed", string page="Random"]],
    point translation=0
    [[string label="Random Translate", string page="Random", float sensitivity=0.01]],
    float rotation=180
    [[string label="Random Rotate", string page="Random", float slidermin=0, float slidermax=360]],
    float scaling=0.5
    [[string label="Random Scale", string page="Random", float min = 0, float max = 2, float slidermin=0, float slidermax=1]],
    vector tangent_in = 0
    [[string label="Tangent In", string page = "Tangent"]],

    output point UV_Offset=0,
    output matrix Tangent_Space=matrix(1)
)
{
    float softness = mix(0, sqrt(3.)/8, soft);
    point uv = vector(u * 0.5,v,0) * tiles + point(1,1,0);

    vector T = select(normalize(dPdu), tangent_in, isconnected(tangent_in));

    vector hex_aspect = vector(1, sqrt(3), 0);
    vector half_aspect = 0.5 * hex_aspect;
    vector odd_offset = vector(0.25 * hex_aspect.x, 0.5 * hex_aspect.y, 0);
    vector rnd_blend = noise("hash", P);
    vector multiplier = vector(2, 1, 0);

    vector soft_blend = softness * (2 * rnd_blend - 1);

    point uv_a = multiplier * (fmod(uv, hex_aspect) - half_aspect);
    point uv_b = multiplier * (fmod(uv + vector(half_aspect.x,0,0), hex_aspect) - half_aspect);

    point a = multiplier * (floor(uv / hex_aspect) - vector(0.5,0,0));
    point b = multiplier * (floor((uv - vector(half_aspect.x,0,0)) / hex_aspect));

    vector rnd_a = 2 * noise("hash", a + seed) - 1;
    vector rnd_b = 2 * noise("hash", b + seed + 123) - 1;

    vector uv_ar = rotate(uv_a, radians(rotation) * rnd_a.x, vector(0,0,1));
    vector uv_br = rotate(uv_b, radians(rotation) * rnd_b.x, vector(0,0,1));
    float height_a = texture(height_texture, uv_ar.x, uv_ar.y, "missingcolor", color(0));
    float height_b = texture(height_texture, uv_br.x, uv_br.y, "missingcolor", color(0));
    vector noise_blend = mix(0, noise("perlin", P / (noise_uniform_scale * noise_scale) + noise_offset), noise_weight);

    float selector_one = (abs(uv_b.x) + soft_blend.x - mix(0, height_b, height_weight) - noise_blend.x) < (abs(uv_a.x) + soft_blend.y - mix(0, height_a, height_weight) - noise_blend.y);

    point uv_one = select(uv_ar, uv_br, selector_one);

    vector T_one = select(
        rotate(T, radians(rotation) * rnd_a.x, Ng),
        rotate(T, radians(rotation) * rnd_b.x, Ng),
        selector_one);
    point center_one = select(a, b, selector_one);
    vector rnd_one = select(rnd_a, rnd_b, selector_one);

    uv_a = multiplier * (fmod(uv - odd_offset, hex_aspect) - half_aspect);
    uv_b = multiplier * (fmod(uv + vector(half_aspect.x,0,0) - odd_offset, hex_aspect) - half_aspect);
    a = multiplier * (floor((uv - odd_offset) / hex_aspect) - vector(0.5,0,0));
    b = multiplier * (floor((uv - vector(half_aspect.x,0,0) - odd_offset) / hex_aspect));
    rnd_a = 2 * noise("hash", a + seed + 789) - 1;
    rnd_b = 2 * noise("hash", b + seed + 456) - 1;

    uv_ar = rotate(uv_a, radians(rotation) * rnd_a.x, vector(0,0,1));
    uv_br = rotate(uv_b, radians(rotation) * rnd_b.x, vector(0,0,1));
    float height_c = texture(height_texture, uv_ar.x, uv_ar.y, "missingcolor", color(0));
    float height_d = texture(height_texture, uv_br.x, uv_br.y, "missingcolor", color(0));
    noise_blend = mix(0, noise("perlin", (P + 742) / (noise_uniform_scale * noise_scale) + noise_offset), noise_weight);

    float selector_two = (abs(uv_b.x) + soft_blend.x - mix(0, height_d, height_weight) - noise_blend.x) < (abs(uv_a.x) + soft_blend.y - mix(0, height_c, height_weight) - noise_blend.y);

    point uv_two = select(
        rotate(uv_a, radians(rotation) * rnd_a.x, vector(0,0,1)),
        rotate(uv_b, radians(rotation) * rnd_b.x, vector(0,0,1)),
        selector_two);
    vector T_two = select(
        rotate(T, radians(rotation) * rnd_a.x, Ng),
        rotate(T, radians(rotation) * rnd_b.x, Ng),
        selector_two);
    point center_two = select(a, b, selector_two);
    vector rnd_two = select(rnd_a, rnd_b, selector_two);

    float selector_three = (length(uv_one) + soft_blend.z - max(height_a, height_b) - noise_blend.z) > (length(uv_two) + soft_blend.x - max(height_c, height_d) - noise_blend.x);

    vector rnd = select(rnd_one, rnd_two, selector_three);
    vector rnd2 = noise("hash", rnd + 42);

    T = select(T_one, T_two, selector_three);
    vector B = cross(T, Ng);

    point uv_final = select(mix(1, rnd2.x + 0.5, scaling) * uv_one + translation * rnd + center_one, mix(1, rnd2.y + 0.5, scaling) * uv_two + translation * rnd + center_two, selector_three);

    UV_Offset = uv_final - point(u, v, 0) + point(0.5, 0.5, 0);
    Tangent_Space = matrix(
        T.x,  T.y,  T.z,  0,
        B.x,  B.y,  B.z,  0,
        Ng.x, Ng.y, Ng.z, 0,
        0,    0,    0,    1
    );

}